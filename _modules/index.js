/**
 * 模块 Modules
 * 
 * Node又一个简单的模块加载系统，在Node中，文件和模块是一一对应的，每个文件被视为一个单独的模块
 * 
 * 模块内的本地对象是私有的，因为模块被Node包装在一个函数中，如果你希望将你的模块根导出为一个函数
 * 或一次导出一个完整的对象而不是每一次都创建一个属性，请赋值给module.exports
 * 
 */

/**
 * 
 * 方法和属性
 * 
 *  module对象
 *  在每个模块中，自由变量module是表示对当前模块的对象的引用，module.exports也可以通过模块全局的exports对象访问到
 *  module实际上不是全局的，而是每个模块内部的
 * 
 *      id 模块的标志符
 *      filename 模块完全解析后的文件名
 *      loaded 显示模块是否已经加载完成，或正在加载中
 *      parent 在模块中最先引入的模块。
 *      children 需要引入该模块的模块对象
 *      exports
 */
const fs = require('fs');
console.log(module);

/**
 * 核心模块
 *  Node 中有些模块是编译成二进制的。
 *  核心模块定义在Node源代码的lib/目录下
 *  require()总是会优先加载核心模块
 */

/**
 * 模块包装器
 *  在执行模块代码之前，Node会使用一个如下所示的函数包装器将其包装
 */

// (function (exports, require, module, __filename, __dirname) {
//     // ...
// })


/**
 * 将文件夹作为模块
 *  可以把程序和库放到一个单独的文件夹里， 并提供单一入口来指向它。有三种方式可以将文件夹传递给require() 作为参数
 * 
 */

/**
 * 循环
 *  当循环调用require()时，模块可能在未完成执行时被返回
 */

/**
 * 当 main.js 加载 a.js 时，a.js 反向加载 b.js。那时，b.js 会尝试去加载 a.js。为了防止无限的循环，a.js 会返回一个 exports 对象的 未完成副本 给 b.js 模块。之后 b.js 完成加载，并将 exports 对象返回给 a.js 模块。
 */

/**
 * 缓存
 * 
 *  模块在第一次加载后会被缓存，（类似其他缓存机制），这意味着如果每次调用require('foo')都解析到同一个
 *  文件，它将返回相同的对象
 * 
 *  多次调用require('foo') 未必会导致模块中的代码执行多次，这是一个重要的特性，借助它，可以返回 部分完成 的对象，从而允许传递依赖性加载，即使它们会导致循环
 * 
 *  如果你希望一个模块能执行多次，那么可以导出一个函数，然后多次调用该函数
 * 
 * 模块缓存的注意事项， 模块是基于其解析的文件名进行缓存的
 */